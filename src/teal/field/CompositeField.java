/*
 * TEALsim - MIT TEAL Project
 * Copyright (c) 2004 The Massachusetts Institute of Technology. All rights reserved.
 * Please see license.txt in top level directory for full license.
 * 
 * http://icampus.mit.edu/teal/TEALsim
 * 
 * $Id: CompositeField.java,v 1.12 2010/07/21 21:54:27 stefan Exp $
 * 
 */

package teal.field;

import java.util.*;

import javax.vecmath.*;

import teal.core.*;

/**
 * 
 * @author Andrew McKinney
 * @author Phil Bailey
 * @author Michael Danziger
 * @version $Revision: 1.12 $ 
 */

/**
 * CompositeField represents the composite field generated by a series of objects.  It is used by the simulation to compute
 * the total field at any given position due to the appropriate field-generating elements in the scene.
 */
public abstract class CompositeField extends Field {

    /**
	 * 
	 */
	private static final long serialVersionUID = -8665514762076904053L;

	public abstract void add(TElement obj) throws ClassCastException;

    /**
     * Returns the objects contributing to this CompositeField.
     * 
     * @return	a Vector of objects.
     */
    public abstract Vector<?> getObjects();

    /**
     * Removes the indicated object from the CompositeField.
     * 
     * @param obj Object to remove from the CompositeField.
     */
    public abstract void remove(TElement obj);

    /**
     * The abstract method "get()" is the generalized function for returning the value of the CompositeField at the given
     * position.  It should be implemented in derived classes according to the specific field type that the CompositeField
     * represents (ie. EField, BField, etc.).  The supplied TElement should be excluded from contributing to the total 
     * field as a way to determine the field acting on that object (an object does not feel it's own field).
     * 
     * @param x Position at which to calculate the total field.
     * @param excludeObj Object to exclude from the calculation.
     * @return Total field, minus the field generated by excludeObj, at x.
     */
    public abstract Vector3d get(Vector3d x, TElement excludeObj);

    /**
     * Deprecated, same as get(Vector3d x, TElement excludeObj).
     * 
     * @param x
     * @param excludeObj
     * @param t
     * @return theFieldValue
     */
    public abstract Vector3d get(Vector3d x, TElement excludeObj, double t);

    // Quick implementation to avoid adding this method to all children.
    public double getPotential(Vector3d pos) {
        return 0.;
    }

    /**
     * Returns the gradient of the CompositeField at x, minus the contribution from excludeObj.
     * 
     * @param x Position at which to calculate the gradient of the field.
     * @param excludeObj Object to exclude from the calculation.
     * @return The gradient of the field, minus the contribution from excludeObj, at x.
     */
    public Matrix3d getGradient(Vector3d x, TElement excludeObj) {
        Vector3d[] F = new Vector3d[] { get(new Vector3d(x.x + epsilon, x.y, x.z), excludeObj),
                get(new Vector3d(x.x - epsilon, x.y, x.z), excludeObj),
                get(new Vector3d(x.x, x.y + epsilon, x.z), excludeObj),
                get(new Vector3d(x.x, x.y - epsilon, x.z), excludeObj),
                get(new Vector3d(x.x, x.y, x.z + epsilon), excludeObj),
                get(new Vector3d(x.x, x.y, x.z - epsilon), excludeObj) };
        /*	
         for(int i = 0;i < F.length;i++)
         {
         TDebug.println(1,"F[" + i+ "]= " + F[i]);
         }
         */
        return computeGradient(F);
    }

    public Matrix3d getGradient(Vector3d x, TElement excludeObj, double t) {
        Vector3d[] F = new Vector3d[] { get(new Vector3d(x.x + epsilon, x.y, x.z), excludeObj, t),
                get(new Vector3d(x.x - epsilon, x.y, x.z), excludeObj, t),
                get(new Vector3d(x.x, x.y + epsilon, x.z), excludeObj, t),
                get(new Vector3d(x.x, x.y - epsilon, x.z), excludeObj, t),
                get(new Vector3d(x.x, x.y, x.z + epsilon), excludeObj, t),
                get(new Vector3d(x.x, x.y, x.z - epsilon), excludeObj, t) };
        return computeGradient(F);
    }
}
