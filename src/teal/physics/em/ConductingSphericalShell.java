/*
 * TEALsim - MIT TEAL Project
 * Copyright (c) 2004 The Massachusetts Institute of Technology. All rights reserved.
 * Please see license.txt in top level directory for full license.
 * 
 * http://icampus.mit.edu/teal/TEALsim
 * 
 * $Id: ConductingSphericalShell.java,v 1.14 2011/05/27 15:39:33 pbailey Exp $ 
 * 
 */

package teal.physics.em;

import java.awt.*;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;

import javax.swing.ImageIcon;
import javax.vecmath.*;

import teal.config.*;
import teal.render.BoundingSphere;
import teal.render.scene.*;
import teal.util.TDebug;
import teal.render.j3d.ShapeNode;
import teal.render.j3d.geometry.Pipe;
import teal.sim.properties.HasLength;
import teal.sim.properties.HasRadius;
import teal.sim.properties.HasThickness;

/**
 * Represents a conducting spherical isolated shell centered at the origin in the presence of a point charge.
 */
public class ConductingSphericalShell extends EMObject implements HasCharge, GeneratesE, GeneratesP,
HasRadius,HasThickness,HasLength{

    private static final long serialVersionUID = 3257003259120924471L;
    
    protected double charge;
    protected double height;
    protected double thickness;
    protected Vector3d FreeChargePosition;
	protected transient double charge_d;
	protected boolean generatingEField= true;
	protected boolean generatingPField= true;
	protected boolean generatingEPotential= true;
	
	protected int fluxMode;

	protected double radius;
	protected double pauliDistance = -1.;
	
	protected double epsilon= 1.0;

	public ConductingSphericalShell() {
		super();
		nodeType = NodeType.PIPE;
		mMaterial.setShininess(0.8f);
		charge= charge_d= 0.0;
		mass= mass_d= Teal.PointChargeMass;
		fluxMode = 0;
		selectColor();
		setPickable(true);
		setRotable(false);
        thickness = 2.;
        radius = 4.;
		height = .1;
		createBounds();
		FreeChargePosition = new Vector3d(0.,5.,0.);
		}

	protected Shape makeShape() {
		return new Ellipse2D.Double(-radius, -radius, radius * 2.0, radius * 2.0);
	}

	public ImageIcon getIcon() {
		if (icon == null) {
			makeIcon();
		}
		return icon;
	}

	public void makeIcon() {

		int iconSize= Teal.iconSize;
		int border= Teal.iconBorderSize;
		BufferedImage img= new BufferedImage(iconSize, iconSize, BufferedImage.TYPE_INT_RGB);
		Graphics2D g= img.createGraphics();
		g.setColor(Teal.iconBackground);
		g.fillRect(0, 0, iconSize, iconSize);
		GradientPaint gp= new GradientPaint(border, border, Color.white, iconSize - border, iconSize - border, mMaterial.getDiffuse().get());
		g.setPaint(gp);

		g.fill(new Ellipse2D.Double(border, border, iconSize - 2 * border, iconSize - 2 * border));
		icon= new ImageIcon(img);
	}
	protected void selectColor() {
	//	if (charge > 0) {
	//		if (mColor.get() != Teal.PointChargePositiveColor)
	//			setColor(Teal.PointChargePositiveColor);
	//	}
	//	else if (charge < 0) {
	//		if (mColor.get() != Teal.PointChargeNegativeColor)
	//			setColor(Teal.PointChargeNegativeColor);
	//	}
	//	else {
	//		if (mColor.get() != Teal.PointChargeNeutralColor)
				setColor(Teal.PointChargeNeutralColor);
	//	}
	}

	protected TNode3D makeNode() {
//		TShapeNode node = (TShapeNode) new ShapeNode();
//		node.setGeometry(Pipe.makeGeometry(50, radius-thickness/2., thickness, height));
//        node.setElement(this);
//		node.setRotable(false);
//		node.setScale(radius);
		TNode3D node = SceneFactory.makeNode(this);
//		node.setColor(teal.render.TealMaterial.getColor3f(mMaterial.getDiffuse()));
//        node.setShininess(mMaterial.getShininess());
//        node.setTransparency(1.f);
        node.setPickable(isPickable);
        
		return node;
	}

	public Vector3d getE(Vector3d position, double t) {
		return getE(position);
	}

	/**
	 * <code>getE</code> returns the electric field generated by
	 * this PointCharge at a certain position.
	 *
	 * @param pos Distance at which E Field is calculated
	 * @return E Field at position
	 */

	public Vector3d getE(Vector3d pos) {
		double radiusobserver = pos.length(); // this is how far the free charge is from the center of the conducting sphere, whose center is at the origin
		double radiusfree = FreeChargePosition.length(); // this is how far the observer is from the center of the conducting sphere, whose center is at the origin
		double ro;
		Vector3d r= new Vector3d(0.,0.,0.);
		
		if(radiusfree >= radius) {  //  this is the case where the free charge is outside the shell
			
			if ( radiusobserver < radius) {  // observer inside the shell
			// here we are calculating the field due to the induced charges on
			// the surface of the sphere when we are INSIDE the sphere.  The E field is just the negative
			// of the E field due to the real charge
				r.sub(pos, FreeChargePosition);  // the vector from the real charge to the observer
				ro= r.lengthSquared();
				r.normalize();
				r.scale(-1.*this.charge_d / (Teal.fourPiPermVacuum * ro));  // the negative of the electric field due to the real charge
			}
			
			else {
				// this is the field due to the induced charges when we are OUTSIDE the sphere.  The E field is
				// due to an image charge of -q*radius^2/(distance to real charge) located inside the sphere and
				// a uniform charge density of the opposite of this on the surface of the sphere, so that
				// the net induced charge on the sphere is zero
				
				//first the field of the image charge inside the sphere at a distance radius^2/radiusfree
				Vector3d rimage = new Vector3d();
				rimage.scale(radius*radius/(radiusfree*radiusfree),FreeChargePosition);  // this is the location of the image in terms of the location of the real charge
				r.sub(pos, rimage);  // the vector from the image charge to the observer
				ro= r.lengthSquared();
				r.normalize();
				r.scale(-1.*radius*this.charge_d/(radiusfree*Teal.fourPiPermVacuum * ro));		// the electric field of the image charge
				// now the uniform charge on the surface
				Vector3d r1 =new Vector3d();
				r1.scale(1.,pos);  // vector from the origin to the observer
				ro= r1.lengthSquared();
				r1.normalize();
				r1.scale(this.charge_d*radius / (radiusfree*Teal.fourPiPermVacuum * ro));
				r.add(r1);
			}
		}
		
		if( radiusfree < radius && radiusfree >= radius-thickness) {  
			//  this is the case where the free charge is inside the conducting part of the shell
			
			if ( radiusobserver < radius) {  // observer inside the shell
				// here we are calculating the field due to the induced charges on
				// the outer surface of the sphere when we are INSIDE the sphere.  The E field is just the negative
				// of the E field due to the real charge
					r.sub(pos, FreeChargePosition);  // the vector from the real charge to the observer
					ro= r.lengthSquared();
					r.normalize();
					r.scale(-1.*this.charge_d / (Teal.fourPiPermVacuum * ro));  // the negative of the electric field due to the real charge
				}
				
				else {
					// this is the field due to the induced charges when we are OUTSIDE the sphere.  The E field is
					// due to a uniform charge density of + q on the surface of the sphere, minus the field
					// due to the free charge, so that adding in the free charge field just gives the field
					// due to a uniform charge
					Vector3d r1 =new Vector3d();
					r1.scale(1.,pos);  // vector from the origin to the observer
					ro= r1.lengthSquared();
					r1.normalize();
					r1.scale(this.charge_d*radius / (radiusfree*Teal.fourPiPermVacuum * ro));
					r.add(r1);  // this is the field due to a uniform charge
					Vector3d r2 = new Vector3d();
					r2.sub(pos, FreeChargePosition);  // the vector from the real charge to the observer
					ro= r2.lengthSquared();
					r2.normalize();
					r2.scale(-1.*this.charge_d / (Teal.fourPiPermVacuum * ro));  // the negative of the electric field due to the real charge
					r.add(r2);
				}
		}
		
			if( radiusfree < radius-thickness) {  
				//  this is the case where the free charge is in the interior of the shell, not in the conducting part
				
				if ( radiusobserver <= radius-thickness) {  // observer inside the conductor
					// The E field here is due to an image charge of -q located outside the sphere
					
					//first the field of the image charge inside the sphere at a distance radiusOuter^2/radiusfree
					Vector3d rimage = new Vector3d();
					double innerradius = radius - thickness;
					rimage.scale(innerradius*innerradius/(radiusfree*radiusfree),FreeChargePosition);  // this is the location of the image in terms of the location of the real charge
					r.sub(pos, rimage);  // the vector from the image charge to the observer
					ro= r.lengthSquared();
					r.normalize();
					r.scale(-1.*this.charge_d/(Teal.fourPiPermVacuum * ro));		// the electric field of the image charge
			}
			
				if ( radiusobserver <= radius && radiusobserver > radius-thickness) {  // observer inside the conductor
					// here we are calculating the field due to the induced charges when the observer is
					// inside the conductor.  The E field is just the negative
					// of the E field due to the real charge, so that the net field is zero
						r.sub(pos, FreeChargePosition);  // the vector from the real charge to the observer
						ro= r.lengthSquared();
						r.normalize();
						r.scale(-1.*this.charge_d / (Teal.fourPiPermVacuum * ro));  // the negative of the electric field due to the real charge
					}
					
				if ( radiusobserver > radius) {  // observer outside the shell
						// this is the field due to the induced charges when the observer is OUTSIDE the sphere.  The E field is
						// due to a uniform charge density of + q on the surface of the sphere, minus the field
						// due to the free charge, so that adding in the free charge field just gives the field
						// due to a uniform charge
						Vector3d r1 =new Vector3d();
						r1.scale(1.,pos);  // vector from the origin to the observer
						ro= r1.lengthSquared();
						r1.normalize();
						r1.scale(this.charge_d*radius / (radiusfree*Teal.fourPiPermVacuum * ro));
						r.add(r1);  // this is the field due to a uniform charge
						Vector3d r2 = new Vector3d();
						r2.sub(pos, FreeChargePosition);  // the vector from the real charge to the observer
						ro= r2.lengthSquared();
						r2.normalize();
						r2.scale(-1.*this.charge_d / (Teal.fourPiPermVacuum * ro));  // the negative of the electric field due to the real charge
						r.add(r2);
					}
		}
	return r;
	}
	
	public double getEFlux(Vector3d pos) {
		
		if (fluxMode == 0) {
			// this is only going to work on the y axis for now
			double flux;
			double q = getCharge();
			double sign = (q >= 0.) ? 1.0 : -1.0;
			Vector3d myPosition = new Vector3d(FreeChargePosition);
			if ((Math.abs(myPosition.x) > 0.0001) || (Math.abs(myPosition.z) > 0.0001)) 
			{
				TDebug.println(0,"PointCharge.getEFlux:  PointCharge is off y-axis, flux calculation does not apply.");
			}
			
			double a = pos.y - myPosition.y;
			double b = Math.sqrt(Math.pow(pos.x,2.0) + Math.pow(a,2.0));
			flux = 0.5*q*(1. - (a/b));
	        
	       return flux;	
		} else if (fluxMode == 1) {
//			 this is only going to work on the y axis for now
			double flux;
			double q = getCharge();
			double sign = (q >= 0.) ? 1.0 : -1.0;
			Vector3d myPosition = new Vector3d(position_d);
			if ((Math.abs(myPosition.x) > 0.0001) || (Math.abs(myPosition.z) > 0.0001)) 
			{
				TDebug.println(0,"PointCharge.getEFlux:  PointCharge is off y-axis, flux calculation does not apply.");
			}
			
			double a = pos.y - myPosition.y;
			double b = Math.sqrt(Math.pow(pos.x,2.0) + Math.pow(a,2.0));
			flux = 0.5*q*(-1. - (a/b));
	        
	        
			return flux;	
		} else {
			return 0.0;
		}
	}
	
	public int getFluxMode() {
		return fluxMode;
	}
	
	public void setFluxMode(int mode) {
		fluxMode = mode;
	}
	

	public void setGeneratingE(boolean b) {
		generatingEField= b;
		if(theEngine != null)
			theEngine.requestSpatial();
	}

	public boolean isGeneratingE() {
		return generatingEField;
	}
	public Vector3d getP(Vector3d position, double t) {
		return getP(position);
	}

	/**
	 * <code>getP</code> returns the Pauli field generated by this
	 * PointCharge at a point.
	 *
	 * @param pos Distance at which P Field is calculated
	 * @return P Field
	 */
	public Vector3d getP(Vector3d pos) {
		Vector3d R = new Vector3d();
		R.sub(pos, this.FreeChargePosition);
		double r_2 = R.lengthSquared();
		double r = R.length();

		// k = Pauli power.	
		double k = 3.0;
		// r0 = Pauli distance.	
		double r0 = (pauliDistance < 0.)?(2.*radius):pauliDistance;

		R.normalize();

		// A scale of 1 exactly counterbalances the electric field.
		// Ad-hoc scale.
//		double scale = (r>r0)?0.:(10.*(r0-r)/r0+1.);
		// Pauli scale.
		double scale = Math.pow(r0/r, (k-2.));
		R.scale( Math.abs(this.charge_d) * scale / (Teal.fourPiPermVacuum * r_2));

		return R;
	}

	public void setGeneratingP(boolean b) {
		generatingPField= b;
		if(theEngine != null)
		theEngine.requestSpatial();
	}

	public boolean isGeneratingP() {
		return generatingPField;
	}

	public Vector3d getB(Vector3d pos) {
		Vector3d eVector= getE(pos);
		Vector3d bVector= new Vector3d();
		bVector.cross(velocity_d, eVector);
		bVector.scale(1 / Math.pow(3e8, 2.0));
		return bVector;
	}

	public Matrix3d getGradientBField(Vector3d pos) {
		Matrix3d m= new Matrix3d();
		Vector3d bFieldTest;
		Vector3d bField= getB(pos);

		bFieldTest= getB(new Vector3d(pos.x + this.epsilon, pos.y, pos.z));
		m.m00= m.m10= m.m20= (bFieldTest.x - bField.x) / this.epsilon;
		bFieldTest= getB(new Vector3d(pos.x, pos.y + this.epsilon, pos.z));
		m.m01= m.m11= m.m21= (bFieldTest.y - bField.y) / this.epsilon;
		bFieldTest= getB(new Vector3d(pos.x, pos.y, pos.z + this.epsilon));
		m.m02= m.m12= m.m22= (bFieldTest.z - bField.z) / this.epsilon;

		return m;
	}

	/**
	 * this returns a newly constructed Matrix with all values set to zero.
	 */
	public Matrix3d getGradientEField(Vector3d pos) {
		return new Matrix3d();
	}
	public double getEPotential(Vector3d pos, double time) {
		return getEPotential(pos);
	}
	public double getEPotential(Vector3d pos) {
		Vector3d r = new Vector3d();
		r.sub(pos, this.FreeChargePosition);
		return getCharge()/r.length();  // fixed major problem, before 8/6/2008 this was returing charge 
		//times distance, not charge/distance  jwb
	}
	public boolean isGeneratingEPotential() {
		return generatingEPotential;
	}
	
    public void setFreeChargePosition(Vector3d FreeChargePosition) {
        this.FreeChargePosition = FreeChargePosition;
    }
    
    public Vector3d getFreeChargePosition() {
        return this.FreeChargePosition;
    }
	public double getCharge() {
		return this.charge;
	}

    public void setCharge(double ch) {
        setCharge(ch,true);
    }
	public void setCharge(double ch,boolean needsRefresh) {
		if (ch != charge) {
			Double old = new Double(charge);
			charge_d= ch;
			charge= ch;
			selectColor();
			firePropertyChange("charge",old,new Double( charge));
			if (theEngine != null)
				theEngine.requestSpatial();	
		}
	}

	public double getRadius() {
		return this.radius;
	}

	
	public void setRadius(double r) {
		if (r != radius) {
			Double old = new Double(radius);
			
			radius= r;
            bounds = null;
            createBounds();
            firePropertyChange("radius",old,new Double( radius));
			if (mNode != null)
            {
                 mNode.setScale(radius);
            }
			if (theEngine != null)
				theEngine.requestRefresh();
		}
	}
	

	public double getThickness() {
		return this.thickness;
	}
	
	public void setThickness(double distance)
	{
		this.thickness = distance;
		if(theEngine != null)
			theEngine.requestSpatial();
	}
	
	public double getPauliDistance()
	{
		return this.pauliDistance;
	}
	
	public void setPauliDistance(double distance)
	{
		this.pauliDistance = distance;
		if(theEngine != null)
			theEngine.requestSpatial();
	}
	
	

	protected void createBounds()
	{
	    bounds = new BoundingSphere(new Point3d(),radius);
	}

	public Vector3d getExternalForces() {
		Vector3d externalForces= super.getExternalForces();
		Vector3d temp= new Vector3d();
		if (isMoveable()) {
//			temp.scale(charge_d, ((EMEngine)theEngine).getEField().get(FreeChargePosition, this)); // F=qE
			temp.scale(charge_d, theEngine.getElementByType(EField.class).get(FreeChargePosition, this)); // F=qE
			externalForces.add(temp);  // force from EField
//			temp.scale(Math.abs(charge_d), ((EMEngine)theEngine).getPField().get(FreeChargePosition, this));
			temp.scale(Math.abs(charge_d), theEngine.getElementByType(PField.class).get(FreeChargePosition, this));
			externalForces.add(temp); // Pauli repulsion
//			temp.cross(velocity_d,((EMEngine)theEngine).getBField().get(FreeChargePosition,this));
			temp.cross(velocity_d,theEngine.getElementByType(BField.class).get(FreeChargePosition,this));
			temp.scale(charge_d);
			//System.out.println("q vxB force" + temp);
			externalForces.add(temp);  //  q vxB force
		}
		return externalForces;
	}
	public void update() {
		
		if (charge != charge_d) {
			setCharge(charge_d);
            
        }
        super.update();
	}

	public String toString() {
		return ("Point Charge:" + id);
	}

	
	public double getLength() {
		return height;
	}

	
	public void setLength(double length) {
		height = length;
		
	}

}
