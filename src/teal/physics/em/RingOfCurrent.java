/*
 * TEALsim - MIT TEAL Project
 * Copyright (c) 2004 The Massachusetts Institute of Technology. All rights reserved.
 * Please see license.txt in top level directory for full license.
 * 
 * http://icampus.mit.edu/teal/TEALsim
 * 
 * $Id: RingOfCurrent.java,v 1.52 2010/09/22 15:48:10 pbailey Exp $ 
 * 
 */

package teal.physics.em;

//import javax.media.j3d.*;
import javax.swing.*;
import javax.vecmath.*;

import teal.config.*;
import teal.math.*;
import teal.render.*;
import teal.render.primitives.Torus;
import teal.render.scene.*;
import teal.sim.engine.*;
import teal.sim.properties.HasRadius;
import teal.sim.properties.HasThickness;
import teal.util.*;

/** The ring of current class.  This class knows how to generate the electric and magnetic fields of a moving ring 
 * carrying current I.  The ring also has inductance and resistance.  It is more complicated than any other extension
 * of EMObject because it has the ability to integrate the external field due to other magnetic field producing objects
 * in the world over its area, that is to calculate the total external magnetic flux through itself.  This is used if
 * we want to calculate the induced current in the ring due to changing flux through the ring due to other objects in 
 * the world.  Note also that since the ring has finite extent when we come to calculate the force on the ring due to
 * external magnetic fields we have to integrate dF = i dl x B around the perimeter of the ring to get the total force. 
 * 
 * @author Phillip Bailey
 * @version 1.0
 */

public class RingOfCurrent extends EMObject implements HasRadius, HasThickness, HasCurrent, HasResistance, HasInductance, GeneratesE,
    GeneratesB, MetaIntegratable {

    private static final long serialVersionUID = 3977297728784839478L;
/** AXIAL means that the ring can only move along its axis. */
    public final static int AXIAL = 1 ;
/** GENERAL means that the ring can move arbitrarily. */    
    public final static int  GENERAL = 2;
/** The current in the ring. */
    protected double current = 0.; //Teal.ringOfCurrentDefaultCurrent;
/** not sure what this is */
    protected double current_d = Teal.RingOfCurrentDefaultCurrent;
/** The resistance of the ring. */
    protected double resistance = Teal.RingOfCurrentDefaultResistance;
/** not sure what this is */
    protected double resistance_d = Teal.RingOfCurrentDefaultResistance;
/** The inductance of the ring.  */
    protected double inductance = Teal.RingOfCurrentDefaultInductance;
/** not sure what this is */
    protected double inductance_d = Teal.RingOfCurrentDefaultInductance;

    protected double radius_d = Teal.RingOfCurrentDefaultRadius;

    protected double radial_derivative = 0.;
/** If true the ring generates a B field. */
    protected boolean generatingBField = true;
/** If true the ring generates an E field. */
    protected boolean generatingEField = false;
    /** Combined integration variable: Current + Flux/Inductance */ 
    protected double combined_d = 0.0;

    protected boolean is_combined_d_initialized = false;
/** If true the presence of a changing external magnetic flux through the ring generates a current. */
    protected boolean inducing = false;
/** If true then all of the external magnetic fields are symmetric about the axis of the ring of current. This
 *  simplifies the integration to a one instead of a two dimensional integration.  */
    protected int integrationMode = AXIAL;

    protected double computed_flux_d;

    protected boolean is_flux_d_computed = false;
/** The outer radius of the torus representing the ring. */
    protected double radius = Teal.RingOfCurrentDefaultRadius;
/** The inner radius of the torus representing the ring. */
    protected double torusRadius = Teal.RingOfCurrentDefaultTorusRadius;
/** The displacement value used to calculate the derivative of the magnetic field generated by the ring. */
    double epsilon = 0.001; //1.0;
/** If true the ring responds to external magnetic fields. */
    protected boolean feelsBField = true;
/** Default accurancy for elliptic integral computation. */
    protected double CEIaccuracy = 0.0002;  // default accuracy for elliptic Integral computation
    
    // *************************************************************************
    // Constructor and Standard Methods
    // *************************************************************************

    public RingOfCurrent() {
        super();
        nodeType=nodeType.TORUS;
        setMoveable(false);
        setRotable(false);
        setPickable(true);
        setColor(Teal.RingOfCurrentColor);
        mMaterial.setShininess(0.5f);
        bounds = null;
    }

    public String toString() {
        return "RingOfCurrent: " + id;
    }

    public ImageIcon getIcon() {
        return (ImageIcon) IconCreator.getIcon("RingOfCurrent.gif");
    }

    public boolean checkProximityToCenter(double[] center, double[] prevPoint, double[] presPoint) {
        if ((prevPoint[1] - center[1]) * (presPoint[1] - center[1]) < 0) {
            TDebug.println(3, "Cross");
            double r1 = ((center[0] - prevPoint[0]) * (center[0] - prevPoint[0]) + (center[1] - prevPoint[1])
                * (center[1] - prevPoint[1]));
            double r2 = ((center[0] - presPoint[0]) * (center[0] - presPoint[0]) + (center[1] - presPoint[1])
                * (center[1] - presPoint[1]));
            double r = radius * radius;
            if (r1 < r && r2 < r) {

                return true;
            }
        }

        return false;
    }

    // *************************************************************************
    // Render and Graphics Methods
    // *************************************************************************

    protected void createBounds() {
        bounds = new BoundingBox(new Point3d(-radius, -torusRadius, -radius), new Point3d(radius, torusRadius, radius));
    }

    protected TNode3D makeNode() {
    	TNode3D node = SceneFactory.makeNode(this);
        node.setPickable(isPickable);
        return node;
    }

    public void render() {
        if (mNode != null) {
            if ((renderFlags & GEOMETRY_CHANGE) == GEOMETRY_CHANGE) {

                mNode = SceneFactory.makeNode(this);

                renderFlags ^= GEOMETRY_CHANGE;
                TDebug.println(1,"ROC geometry change");
            }
            super.render();
        }
    }

    // *************************************************************************
    // Magnetic Field Methods
    // *************************************************************************

    /**
     * Computes the dipole moment of the ring, which is a vector in the
     * direction of the axis of the ring, with magnitude equal to the surface
     * area of the ring multiplied by its current. The current convention is
     * positive counterclockwise with respect to the direction of the dipole moment.
     * 
     * @return Dipole moment of the ring.
     */
    public Vector3d getDipoleMoment() {
        Vector3d temp = getDirection();
        temp.normalize();
        temp.scale(Math.PI * radius_d * radius_d * current_d);
        return temp;
    }

    public void setGeneratingB(boolean b) {
        if (generatingBField != b) {
            boolean old = generatingBField;
            generatingBField = b;
            firePropertyChange("generatingB", old, generatingBField);

            if (theEngine != null) {
                theEngine.requestSpatial();
            }
        }
    }

    public boolean isGeneratingB() {
        return generatingBField;
    }

    /**
     * Evaluates the magnetic field at the given position and time.
     * 
     * @see #getB(Vector3d)
     * @param pos Position to evaluate the magnetic field at.
     * @param t Time to evaluate the magnetic field at.
     * @return Magnetic field value at the given position and time.
     */
    public Vector3d getB(Vector3d pos, double t) {
        return getB(pos);
    }

    /**
     * Evaluates the magnetic field at the given position. If the point of
     * evaluation is on-axis, a closed form expression is used. Otherwise, the
     * <code>ellipticalIntegral</code> method is used for the evaluation.   
     * See Section 3.2 of the 
     * <a href="C:\Development\Projects\generalDoc\TEAL_Physics_Math.pdf"> 
     * TEAL Physics and Mathematics</a> documentation. 
     * 
     * @see teal.math.SpecialFunctions#ellipticIntegral(double, double, double, double, double)
     * @param point Position to evaluate the magnetic field at.
     * @return Magnetic field value at the given position.
     */
    public Vector3d getB(Vector3d point) {

        // If the dipole moment of the ring is zero, we return a zero vector for B.
        Vector3d dipoleMoment = new Vector3d(getDipoleMoment());
        if (dipoleMoment.length() <= Teal.DoubleZero) {
            return new Vector3d();
        }

        // Variable declarations.
        // *********************************************************************
        Vector3d value = null;
        Vector3d temp = new Vector3d();
        Vector3d zprime = new Vector3d();
        Vector3d xprime = new Vector3d();
        Vector3d R = new Vector3d();
        double f, Zprime, Xprime, Zprime_norm, Xprime_norm, Zprime_norm2, BR, BZ;
        double r12, ks, kc, k, h, L1, L2, G0, G1;

        // Computations.
        // *********************************************************************

        // Construct dipole centered coordinate system x'y'z' with z' axis along
        // the ring normal dipole axis M and the x'-axis perpendicular to that
        // vector and in the plane of X and M. The B-field of the ring will have
        // only x' and z' components. Zprime and Rprime are the coordinates of
        // the observation point as seen in this prime coordinate system, as
        // seen from the center of the ring.

        R.sub(position_d, point);
        zprime.set(dipoleMoment);
        zprime.normalize();
        Zprime = zprime.dot(R);
        xprime.set(R);
        temp.set(zprime);
        temp.scale(Zprime);
        xprime.sub(temp);

        // On-axis computation.
        // *********************************************************************
        if (xprime.length() < Teal.DoubleZero) {
            double dK = (R.length() * R.length()) + (radius_d * radius_d);
            dK = Math.pow(dK, 1.5);
            dK = 1. / dK;
            dipoleMoment.scale(2.*dK *Teal.PermitivityVacuumOver4Pi);
            value = dipoleMoment;
            return value;
        }

        // Off-axis computation by elliptic integration.
        // *********************************************************************
        xprime.normalize();
        Xprime = xprime.dot(R);

        //  Normalize lengths to radius of ring
        Zprime_norm = Zprime / radius_d;
        Xprime_norm = Xprime / radius_d;
        Zprime_norm2 = Zprime_norm * Zprime_norm;

        r12 = Zprime_norm2 + (Xprime_norm + 1.) * (Xprime_norm + 1.);
        ks = (Zprime_norm2 + (Xprime_norm - 1.) * (Xprime_norm - 1.)) / r12;
        kc = Math.sqrt(ks);
        k = Math.sqrt(1. - ks);
        h = 1. + ks - (1. - ks) * Xprime_norm;
        G0 = SpecialFunctions.ellipticIntegral(kc, 1., -1., 1.,CEIaccuracy);
        G1 = .5 * SpecialFunctions.ellipticIntegral(kc, ks, -1., 1.,CEIaccuracy);
        L1 = (G0 + h * G1) * k / Math.pow(Xprime_norm, 1.5);
        L2 = Zprime_norm * G1 * k * k * k / Math.pow(Xprime_norm, 1.5);
        f = dipoleMoment.length() / (Math.PI * Math.pow(radius_d, 3.));
        BR = f * L2;
        BZ = f * L1;

        //  We have found the vector field components in our dipole centered
        //  coordinate system. Now we reconstruct the total vector field in xyz.
        
        value = new Vector3d();
        Vector3d repBR = new Vector3d(xprime);
        Vector3d repBZ = new Vector3d(zprime);
        repBR.scale(BR);
        repBZ.scale(BZ);
        value.add(repBR);
        value.add(repBZ);
        value.scale(Teal.PermitivityVacuumOver4Pi);

        return value;
    }

    /**
     * 
     * There is a problem with this function if point is a position on the ring
     * itself, needs a fix.
     * 
     * Evaluates the magnetic flux function at the given position.  We use the flux function as given 
     * by equation (3.2.3.1) of the <a href="C:\Development\Projects\generalDoc\TEAL_Physics_Math.pdf"> 
     * TEAL Physics and Mathematics</a>  documentation.  Note that we are taking mu naught to be 
     * 1 in this expression and multiplying by a factor of 100 simply to make the flux values in a reasonable 
     * range.  Any change in this factor of 100 should be accompanied by similar changes in anything else 
     * used in magnetic flux calculations, e.g. the magnetic dipole.  
     * 
     * @param point Position to evaluate the magnetic flux at.
     * @return Magnetic flux value at the given position.
     */
    public double getBFlux(Vector3d point) {
        double flux;
        Vector3d zprime = new Vector3d();
        Vector3d xprime = new Vector3d();
        Vector3d radiusVector = new Vector3d();
        Vector3d radiusVectorPerpendicular = new Vector3d();
        double Zprime, Xprime, Zprime_norm, Xprime_norm, Zprime_norm2;
        double r12, ks, kc, k, G0;
        Vector3d dipoleMoment = new Vector3d(getDipoleMoment());

        // Construct dipole centered coordinate system x'y'z' with z' axis along
        // the ring normal dipole axis M and the x'-axis perpendicular to that
        // vector and in the plane of X and M. The B-field of the ring will have
        // only x' and z' components. Zprime and Rprime are the coordinates of
        // the observation point as seen in this prime coordinate system, as
        // seen from the center of the ring.

        // First check to see if dipole moment of ring is zero. If so, return 0.
        // for flux
        if (dipoleMoment.length() == 0.0) {
            return 0.0; // no flux
        }
        radiusVector.sub(position_d, point);
        zprime.set(dipoleMoment);
        zprime.normalize();
        Zprime = zprime.dot(radiusVector);
        radiusVectorPerpendicular.set(radiusVector);
        Vector3d temp = new Vector3d(zprime);
        temp.scale(Zprime);
        radiusVectorPerpendicular.sub(temp);
        xprime.set(radiusVectorPerpendicular);
        xprime.normalize();
        Xprime = xprime.dot(radiusVector);

        Zprime_norm = Zprime / radius_d;
        Xprime_norm = Xprime / radius_d;
        Zprime_norm2 = Zprime_norm * Zprime_norm;
        r12 = Zprime_norm2 + (Xprime_norm + 1.) * (Xprime_norm + 1.);
        ks = (Zprime_norm2 + (Xprime_norm - 1.) * (Xprime_norm - 1.)) / r12;
        kc = Math.sqrt(ks);
        k = Math.sqrt(1. - ks);
        G0 = SpecialFunctions.ellipticIntegral(kc, 1., -1., 1.,CEIaccuracy);

        flux = 100. * (Math.pow(Xprime*radius_d, 0.5)) * current_d * k  * G0;

        return flux;
    }

    /**
     * Evaluates the magnetic field gradient at the given position.
     * 
     * @param pos Position to evaluate the magnetic field gradient at.
     * @return Magnetic field gradient at the given position.
     */
    public Matrix3d getGradientBField(Vector3d pos) {
        Matrix3d m = new Matrix3d();
        Vector3d bFieldTest;
        Vector3d bField = getB(pos);

        bFieldTest = getB(new Vector3d(pos.x + epsilon, pos.y, pos.z));
        m.m00 = m.m10 = m.m20 = (bFieldTest.x - bField.x) / epsilon;
        bFieldTest = getB(new Vector3d(pos.x, pos.y + epsilon, pos.z));
        m.m01 = m.m11 = m.m21 = (bFieldTest.y - bField.y) / epsilon;
        bFieldTest = getB(new Vector3d(pos.x, pos.y, pos.z + epsilon));
        m.m02 = m.m12 = m.m22 = (bFieldTest.z - bField.z) / epsilon;

        return m;
    }

 

    // *************************************************************************
    // Electric Field Methods
    // *************************************************************************

    public void setGeneratingE(boolean b) {
        generatingEField = b;
        if (theEngine != null) theEngine.requestSpatial();
    }

    public boolean isGeneratingE() {
        return generatingEField;
    }

    /**
     * Evaluates the electric field at the given position.
     * 
     * @param pos Position to evaluate the electric field at.
     * @return Electric field value at the given and time.
     */
    public Vector3d getE(Vector3d pos) {
        Vector3d bfield = getB(pos);
        Vector3d efield = new Vector3d();
        efield.cross(velocity, bfield);
        efield.scale(-1);
        return efield;
    }

    /**
     * Stub. Must be replaced. Evaluates the electric potential at the given
     * position.
     * 
     * @param pos Position to evaluate the electric potential at.
     * @return Electric potential value at the given position.
     */
    public double getEPotential(Vector3d pos) {
        return 0.;
    }

    /**
     * Stub. Must be replaced. Evaluates the electric flux at the given
     * position.
     * 
     * @param pos Position to evaluate the electric flux at.
     * @return Electric flux value at the given position.
     */
    public double getEFlux(Vector3d pos) {
        return 0.;
    }

    /**
     * Evaluates the electric field at the given position and time.
     * 
     * @param pos Position to evaluate the electric field at.
     * @param t Time to evaluate the electric field at.
     * @return Electric field value at the given position and time.
     */
    public Vector3d getE(Vector3d pos, double t) {
        return getE(pos);
    }

    /**
     * Stub. Must be replaced. Evaluates the electric field gradient at the
     * given position.
     * 
     * @param pos Position to evaluate the electric field gradient at.
     * @return Electric field gradient at the given position.
     */
    public Matrix3d getGradientEField(Vector3d pos) {
        return new Matrix3d();
    }

    // *************************************************************************
    // Ring Properties
    // *************************************************************************

    public double getInductance() {
        return this.inductance;
    }

    public void setInductance(double inductance) {
        this.inductance_d = inductance;
        if (this.inductance != inductance) {
            Double old = new Double(this.inductance);
            this.inductance = inductance;
            firePropertyChange("inductance", old, new Double(this.inductance));
            if (theEngine != null) {
                theEngine.requestSpatial();
            }
        }
    }
/** Gets the resistance of the ring.  */
    public double getResistance() {
        return this.resistance;
    }
/** Sets the resistance of the ring. 
 * @param resistance The resistance of the ring.
 */
    public void setResistance(double resistance) {
        this.resistance_d = resistance;
        if (this.resistance != resistance) {
            Double old = new Double(this.resistance);
            this.resistance = resistance;
            firePropertyChange("resistance", old, new Double(this.resistance));
            if (theEngine != null) {
                theEngine.requestSpatial();

            }
        }
    }
/** Gets the current in the ring. */
    public double getCurrent() {
        return this.current;
    }
/** not sure what this does */
    protected boolean inside_setCurrent = false;
/** Sets the current in the ring. */
    public void setCurrent(double cur) {
        if (inside_setCurrent) return;
        inside_setCurrent = true;

        // Ring reset.
        is_combined_d_initialized = false;

        this.current_d = cur;
        if (Math.abs(this.current - cur) > 1e-14) {
            Double old = new Double(this.current);
            if (hasPropertyChangeListeners("current")) {
                firePropertyChange("current", old, new Double(this.current));
            }
            this.current = cur;

            if (theEngine != null) {
                theEngine.requestSpatial();
            }
        }
        inside_setCurrent = false;
    }
/** Gets the radius of the ring. */
    public double getRadius() {
        return radius_d;
    }
/** Sets the radius of the ring. */
    public void setRadius(double r) {
        Double old = new Double(radius);
        radius = r;
        bounds = null;
        firePropertyChange("radius", old, new Double(radius));
        renderFlags |= GEOMETRY_CHANGE;
        if (theEngine != null) {
            theEngine.requestSpatial();
            if (theEngine.getEngineControl().getSimState() != EngineControl.RUNNING) {
                radius_d = r;
            }
        } else {
            radius_d = r;
        }
    }
/** Gets the radius of the torus that represents the ring.  */
    public double getThickness() {
        return torusRadius;
    }
/** Sets the radius of the torus that represents the ring. 
 * @param r The radius. */
    public void setThickness(double r) {
        Double old = new Double(torusRadius);
        torusRadius = r;
        bounds = null;
        firePropertyChange("torusRadius", old, new Double(torusRadius));
        renderFlags |= GEOMETRY_CHANGE;
        if (theEngine != null) {
            theEngine.requestRefresh();
        }
    }

    // *************************************************************************
    // The new integration methods to achieve induced current.
    // *************************************************************************
/** Sets whether the ring is inducing or not.  If true then a changing magnetic flux through the ring
 * causes an emf around the ring.  
 * 
 * @param x If true the ring can have induced currents, if false it cannot.  */

    public void setInducing(boolean x) {
        inducing = x;
        if (theEngine != null) theEngine.requestSpatial();
    }
/** Checks to see if the ring is inducing or not.  
    @return boolean which is true if the ring is inducing. */
    public boolean isInducing() {
        return inducing;
    }

    public void setIntegrationMode(int x) {
        integrationMode = x;
    }

    public int getIntegrationMode() {
        return integrationMode;
    }

    /*
     * Notes on smooth radius evolution.
     * 
     * When induced currents are taken into account, changes in the ring geometry
     * should be smoothly present during the integration step. The smooth
     * evolution is implemented is through a "radial derivative", which is
     * constant and set to the change in radius, divided by the integration time
     * step.
     * 
     * There's a twist to the usual order of assignment. When an external user
     * sets the radius, the published value immediately changes. The shadow
     * value reflects the old value. The difference is the change in radius
     * referred to above. By integration, the shadow value evolves to the
     * (desired) published value. Thus, there's no need to account for
     * reconcilation in the update step.
     */

    public int getNumberDependentValues() {
        return super.getNumberDependentValues() + (inducing ? 2 : 0);
    }

    public void getDependentValues(double[] depValues, int offset) {
        if (!inducing) {
            radius_d = radius;
            super.getDependentValues(depValues, offset);
            return;
        }

        super.getDependentValues(depValues, offset);
        offset += super.getNumberDependentValues();

        /*
         * Setting is_flux_d_computed to false is not necessarily justified most
         * of the time, specifically when from the end of one integration cycle
         * to the beginning of the other the world is left intact. The best
         * solution is for the ring to "know" whether its flux has actually
         * changed (either by its own displacement, radius change, or the
         * displacement or change of some other B-field generating object in the
         * world). Also refer to the remark in flux_d(). Recomputing the flux
         * here is thus often superfluous but will automatically account for all
         * such changes.
         */
        is_flux_d_computed = false;
        combined_d = current_d + flux_d() / inductance_d;
        is_combined_d_initialized = true;
        depValues[offset++] = combined_d;
        depValues[offset++] = radius_d;
        radial_derivative = (radius - radius_d) / theEngine.getDeltaTime();
    }

    public void setDependentValues(double[] newValues, int offset) {
        if (!inducing) {
            super.setDependentValues(newValues, offset);
            return;
        }
        super.setDependentValues(newValues, offset);
        offset += super.getNumberDependentValues();
        combined_d = newValues[offset++];
        radius_d = newValues[offset++];
        is_flux_d_computed = false;
    }

    public void getDependentDerivatives(double[] depDerivatvies, int offset, double time) {
        if (!inducing) {
            super.getDependentDerivatives(depDerivatvies, offset, time);
            return;
        }
        // Super's dependent derivatives.
        super.getDependentDerivatives(depDerivatvies, offset, time);
        offset += super.getNumberDependentValues();
        // Add combined variable derivative for current induction.
        depDerivatvies[offset++] = -current_d * resistance_d / inductance_d;
        // Add radial derivative.
        depDerivatvies[offset++] = radial_derivative;
    }

    /*
     * Ring of current is meta-integratable: the dependent variable is
     * "combined_d" but after that is set by the integration through
     * "setDependentValues", the "current" variable needs to be set properly
     * too. However, multiple rings have currents that depend on each other's
     * fields, which depend in turn on their respective currents. The world
     * successively calls solveInterdependencies() in order for the values of
     * the currents to settle.
     * 
     * For more detail, refer to SimEngine, from where we borrow the following:
     * 
     * "The setDependentValues method of the world now incorporates a special
     * meta-integration section which resolves the interdependencies between
     * object variables that are not explicitly dependent variables, such as the
     * current in a ring. The simplistic method of successive iterations is
     * capable of yielding acceptable solution in most cases, but might diverge
     * as well. When that happens in the case of the ring, the result is a large
     * jump in current. A possible remedy would be the implementation of a
     * Newton-Raphson family method."
     *  
     */
    public boolean solveInterdependencies() {
        double old_current_d = current_d;
        final double current_ea = 1e-8;
        if (is_combined_d_initialized) {
            is_flux_d_computed = false;
            current_d = combined_d - flux_d() / inductance_d;
        }
        boolean converged = Math.abs(current_d - old_current_d) < current_ea;
        return converged;
    }

    public void update() {
        if (current != current_d) setCurrent(current_d);
        if (inductance != inductance_d) setInductance(inductance_d);
        if (resistance != resistance_d) setResistance(resistance_d);
        super.update();
    }

    /**
     * flux_d() is a "shadow-value method" for computing the flux through the
     * ring surface. It can itself call either a single integration (which works
     * for a general system with axial symmetry), or a double integration (which
     * works for all cases, but is extremely slow).
     */
    protected double flux_d() {

        // Outdated comment. Need to update. 01/17/05
        //
        // * The is_flux_d_computed condition helps cut the number of times the
        // * actual function is evaluated. Since a new recomputation is needed
        // * only if the system changes, is_flux_d_computed is set to true after
        // * computation, and reset only to false when setDependentValues is
        // * called (indicating a world change) or when the radius of the ring is
        // * changed (the flux area is changed). In fact, it should be reset
        // * whenever a B-field generating object is displaced in the world, but
        // * that is not yet implemented (this might require the ring to become a
        // * property change listener, or something equivalent).

        if (is_flux_d_computed) return computed_flux_d;

   //     double old_computed_flux_d = computed_flux_d;

        double ans;
        switch (integrationMode) {
            case GENERAL:
                // ********************************************************
                // * Double Integration *
                // ********************************************************
                ans = doubleIntegrate();
                break;

            case AXIAL:
            default:
                // ********************************************************
                // * Single Integration *
                // ********************************************************
                ans = singleIntegrate();
                break;
        }

        boolean discontinuity = (Math.abs(ans) > (100. * Math.abs(computed_flux_d)));
        

        discontinuity = discontinuity && (Math.abs(computed_flux_d) > Teal.DoubleZero)
            && (Math.abs(ans) > Teal.DoubleZero);
        

        if (discontinuity)
            System.out.println("Discontinuity at time " + theEngine.getTime() + ", previous flux value: "
                + computed_flux_d + ", discontinuous value: " + ans);

        
        if (Double.isNaN(ans) || discontinuity) {
            // Use the old computed_flux_d.
        } else {
            computed_flux_d = ans;
        }

        is_flux_d_computed = true;
        return computed_flux_d;
    }

    /** Unit vector in direction of ring, orthogonal to the plane. */
    protected Vector3d v = new Vector3d();

    /** First unit vector in the plane of the ring */
    protected Vector3d u1 = new Vector3d();

    /** Second unit vector in the plane of the ring */
    protected Vector3d u2 = new Vector3d();

    /**
     * setuv() is called before the integration begins, to define a unit vector
     * in the direction of the ring (v), and two vectors on the plane of the
     * ring, to define the x and y directions of integration (u1 and u2
     * respectively).
     */
    protected void setuv() {
        // Gram-Schmidt Orthogonalization.
        Vector3d d = new Vector3d(getDirection());

        d.normalize();
        v.set(d);
        u1.set(1., 0., 0.);
        v.scale(u1.dot(v));
        u1.sub(v);
        if (u1.length() < Teal.DoubleZero) {
            v.set(d);
            u1.set(0., 1., 0.);
            v.scale(u1.dot(v));
            u1.sub(v);
            if (u1.length() < Teal.DoubleZero) {
                v.set(d);
                u1.set(0., 0., 1.);
                v.scale(u1.dot(v));
                u1.sub(v);
            }
        }

        v.set(d);
        u1.normalize();
        u2.cross(v, u1);
        if (Double.isNaN(v.length())) System.out.println("v is NaN");
        if (Double.isNaN(u1.length())) System.out.println("u1 is NaN");
        if (Double.isNaN(u2.length())) System.out.println("u2 is NaN");
    }

    /**
     * f(x,y) is the dot product of external B fields with the unit vector v,
     * where x and y are the coordinates on the disk of the ring along u1 and u2
     * respectively.
     */
    protected double f(double x, double y) {
        Vector3d t = new Vector3d();
        t.scale(x, u1);
        t.scaleAdd(y, u2, t);
        t.add(position_d);
//        Vector3d B = ((EMEngine)theEngine).getBField().get(t, this);
        Vector3d B = theEngine.getElementByType(BField.class).get(t, this);
        return B.dot(v);
    }

    /**
     * q(r) is equivalent to 2*pi*|r|*f(r,0).
     */
    protected double q(double r) {
        double value = 2. * Math.PI * Math.abs(r) * f(r, 0);
        return value;
    }

    /**
     * g(x) is the partial integral of f(x,y) for fixed x and y varying between
     * -SQRT(r^2-x^2) and SQRT(r^2-x^2). In the double integral, it is
     * integrated itself for x between -r and r, to yield the flux.
     */
    protected double g(double x) {
        /*
         * Pseudocode for Rhomberg intergration FUNCTION Rhomberg(a,b,maxit,es)
         * LOCAL I(10,10) n=1 I1,1=TrapEq(n,a,b) iter=0 DO iter=iter+1 n=2^iter
         * Iiter+1,1=TrapEq(n,a,b) DO k=2, iter+1 j=2+iter-k
         * Ij,k=(4^(k-1)*Ij+1,k-1-Ij,k-1)/(4^(k-1)-1) END DO
         * ea=ABS(I1,iter+1-I1,iter)/I1,iter+1)*100 IF(iter>=maxit OR ea <=es)
         * EXIT END DO Rhomberg = I1,iter+1 END Rhomberg
         */
        // All intergation variables are bulk defined here, unintialized.
        double a = 0., b = 0., c = 0., es = 0., ea = 0., h = 0.;
        double ans = 0.;
        int k = 0, j = 0, iter = 0, m = 0, n = 0, i = 0, maxit = 0;
        // These are the arguments of the integration routine.
        a = -Math.sqrt(radius_d * radius_d - x * x);
        b = -a;
        maxit = 5;
        es = 10.;
        /*
         * I[][] is used to contain integration results at various iteration
         * stages. Note also that the algorithm pseudocode uses indices starting
         * from 1. To avoid errors, I used the pseudocode as is, and that means
         * that zero-indices are simply not used. This can be fixed later by
         * offsetting everything.
         */
        double[][] I = new double[maxit + 2][maxit + 2];

        // The routine starts here, it's an adaptation of the pseudocde.
        iter = 0;
        n = 1;
        h = (b - a);
        I[1][1] = (f(x, a) + f(x, b)) * h / 2.;

        try {

            do {
                iter++;
                n *= 2;
                h /= 2.;
                I[iter + 1][1] = 0;
                c = a;
                for (i = 0; i < n; i++) {
                    I[iter + 1][1] += (f(x, c) + f(x, c + h)) * h / 2.;
                    c += h;
                }
                m = 1;
                for (k = 2; k <= iter + 1; k++) {
                    j = 2 + iter - k;
                    m *= 4;
                    I[j][k] = (m * I[j + 1][k - 1] - I[j][k - 1]) / (m - 1);
                }
                if (I[1][iter + 1] - I[1][iter] == 0) {
                    ea = 0.;
                } else {
                    ea = Math.abs((I[1][iter + 1] - I[1][iter]) / I[1][iter + 1]) * 100.;
                }
            } while (!(iter >= maxit || ea <= es));

            ans = I[1][iter + 1];

        } catch (Exception ex) {
            System.err.println("Caught Exception: " + ex.getMessage());
            ex.printStackTrace();
        }
        return ans;
    }

    protected double doubleIntegrate() {
        // v, u1 and u2 are fixed for this integration pass.
        setuv();

        // All intergation variables are bulk defined here, unintialized.
        double a = 0., b = 0., c = 0., es = 0., ea = 0., h = 0.;
        double ans = 0.;
        int k = 0, j = 0, iter = 0, m = 0, n = 0, i = 0, maxit = 0;
        // These are the arguments of the integration routine.
        a = -radius_d;
        b = radius_d;
        maxit = 5;
        es = 20.;

        /*
         * I[][] is used to contain integration results at various iteration
         * stages. Note also that the algorithm pseudocode uses indices starting
         * from 1. To avoid errors, I used the pseudocode as is, and that means
         * that zero-indices are simply not used. This can be fixed later by
         * offsetting everything.
         */
        double[][] I = new double[maxit + 2][maxit + 2];

        // The routine starts here, it's an adaptation of the pseudocde.
        iter = 0;
        n = 1;
        h = (b - a);
        I[1][1] = (g(a) + g(b)) * h / 2.;

        try {

            do {
                iter++;
                n *= 2;
                h /= 2.;
                I[iter + 1][1] = 0;
                c = a;
                for (i = 0; i < n; i++) {
                    I[iter + 1][1] += (g(c) + g(c + h)) * h / 2.;
                    c += h;
                }
                m = 1;
                for (k = 2; k <= iter + 1; k++) {
                    j = 2 + iter - k;
                    m *= 4;
                    I[j][k] = (m * I[j + 1][k - 1] - I[j][k - 1]) / (m - 1);
                }
                if (I[1][iter + 1] - I[1][iter] == 0) {
                    ea = 0.;
                } else {
                    ea = Math.abs((I[1][iter + 1] - I[1][iter]) / I[1][iter + 1]) * 100.;
                }
            } while (!(iter >= maxit || ea <= es));
            ans = I[1][iter + 1];

        } catch (Exception ex) {
            System.err.println("Caught Exception: " + ex.getMessage());
            ex.printStackTrace();
        }

        return ans;
    }

    protected double singleIntegrate() {
        // v, u1 and u2 are fixed for this integration pass.
        setuv();

        // All intergation variables are bulk defined here, unintialized.
        double a = 0., b = 0., c = 0., es = 0., ea = 0., h = 0.;
        double ans = 0.;
        int k = 0, j = 0, iter = 0, m = 0, n = 0, i = 0, maxit = 0;
        // These are the arguments of the integration routine.
        a = 0.;
        b = radius_d;
        maxit = 10;
        es = 1e-5;

        /*
         * I[][] is used to contain integration results at various iteration
         * stages. Note also that the algorithm pseudocode uses indices starting
         * from 1. To avoid errors, I used the pseudocode as is, and that means
         * that zero-indices are simply not used. This can be fixed later by
         * offsetting everything.
         */
        double[][] I = new double[maxit + 2][maxit + 2];

        // The routine starts here, it's an adaptation of the pseudocde.
        iter = 0;
        n = 1;
        h = (b - a);
        I[1][1] = (q(a) + q(b)) * h / 2.;

        try {

            do {
                iter++;
                n *= 2;
                h /= 2.;
                I[iter + 1][1] = 0;
                c = a;
                for (i = 0; i < n; i++) {
                    I[iter + 1][1] += (q(c) + q(c + h)) * h / 2.;
                    c += h;
                }
                m = 1;
                for (k = 2; k <= iter + 1; k++) {
                    j = 2 + iter - k;
                    m *= 4;
                    I[j][k] = (m * I[j + 1][k - 1] - I[j][k - 1]) / (m - 1);
                }

                if (I[1][iter + 1] - I[1][iter] == 0) {
                    ea = 0.;
                } else {
                    ea = Math.abs((I[1][iter + 1] - I[1][iter]) / I[1][iter + 1]) * 100.;
                }
            } while (!(iter >= maxit || ea <= es));
            ans = I[1][iter + 1];

        } catch (Exception ex) {
            System.err.println("Caught Exception: " + ex.getMessage());
            ex.printStackTrace();
        }

        return ans;
    }

    public void setFeelsBField(boolean x) {
        if (feelsBField != x) {
            feelsBField = x;
            if (theEngine != null) theEngine.requestSpatial();
        }
    }

    /*
     * The methods getExternalForces() and getTorque() should be appropriately
     * populated in order to have mechanically functional rings.
     */

    public Vector3d getExternalForces() {
        Vector3d externalForces = super.getExternalForces();
        if (Double.isNaN(externalForces.length())) {
            System.out.println("NaN in getExternalForces() of RingOfCurrent from super class (gravity).");
        }
        try {
            if (feelsBField) {
                // The calculation below only applies when we have axial
                // symmetry.
                /*
                 * Procedure: - We need to integrate dF = I dS x dB around the
                 * ring to get the net force. - Axial symmetry removes any
                 * radial component in the force. - Axial symmetry, plus each
                 * side current has opposite directions, together imply that
                 * there will be no tangential component. - We are therefore
                 * left with only axial force component. The only field
                 * component that will contribute to this force is the radial
                 * one (due to the cross product), therefore that needs to be
                 * found, on the ring itself. - Thanks to axial symmetry, this
                 * radial B component has constant magnitude around the ring,
                 * therefore no integration is needed. We just have:
                 * 
                 * F = I * 2 * pi * r * Bradial, axially. - The sign follows
                 * from the adopted convention, and will depend on whether
                 * Bradial is outwards or inwards, thus we perform a dot product
                 * for that.
                 */

                // (1) Axial unit vector.
                Vector3d axial = getDirection();
                axial.normalize();

                // (2) Radial unit vector.
                Vector3d radial = new Vector3d(0., 0., 1.);
                double projection_radial_on_axial = radial.dot(axial);
                Vector3d non_radial = new Vector3d(axial);
                non_radial.scale(projection_radial_on_axial);
                radial.sub(non_radial);
                if (radial.length() < Teal.DoubleZero) {
                    radial = new Vector3d(0., 1., 0.);
                    projection_radial_on_axial = radial.dot(axial);
                    non_radial = new Vector3d(axial);
                    non_radial.scale(projection_radial_on_axial);
                    radial.sub(non_radial);
                    if (radial.length() < Teal.DoubleZero) {
                        radial = new Vector3d(1., 0., 0.);
                        projection_radial_on_axial = radial.dot(axial);
                        non_radial = new Vector3d(axial);
                        non_radial.scale(projection_radial_on_axial);
                        radial.sub(non_radial);
                    }
                }
                radial.normalize();

                // (3) Radial vector.
                Vector3d R = new Vector3d(radial);
                R.scale(radius_d);

                // (4) On-ring evaluation of external magnetic field.
                Vector3d evaluateAt = new Vector3d(position_d);
                evaluateAt.add(R);
//                Vector3d B = ((EMEngine)theEngine).getBField().get(evaluateAt, this);
                Vector3d B = theEngine.getElementByType(BField.class).get(evaluateAt, this);

                // (5) Radial component of the on-ring external magnetic field.
                double projection_B_on_radial = B.dot(radial);
                Vector3d Bradial = new Vector3d(radial);
                Bradial.scale(projection_B_on_radial);

                // (6) Force magnitude and vector.
                double magnitude = -2 * Math.PI * radius_d * current_d * Bradial.dot(radial);
                Vector3d force = new Vector3d(axial);
                force.normalize();
                force.scale(magnitude);
                externalForces.add(force);
            }
        } catch (ArithmeticException ae) {
            TDebug.printThrown(0, ae);
        }
        if (Double.isNaN(externalForces.length())) {
            System.out.println("NaN in getExternalForces() of RingOfCurrent from within class (magnetism).");
        }
        return externalForces;
    }

    protected Vector3d getTorque() {
        return new Vector3d();
    }

    public double getExternalFlux() {
        double flux = flux_d();
        return flux;
    }

    public double getTotalFlux() {
        double flux = flux_d();
        return inductance_d * current_d + flux;
    }

    public void reset() {
        is_combined_d_initialized = false;
        is_flux_d_computed = false;
        computed_flux_d = 0.;
    }

    /**
     * Overloading this method enables using the shadow value for orientation.
     * The evaluation of the dipole moment is thus more accurate. This is also
     * crucial for current induction, since a varying orientation during
     * integration is what allows to evaluate, indirectly, the derivative of the
     * flux.
     */
    public Matrix3d getRotationMatrix() {
        Matrix3d mat = new Matrix3d();
        if (orientation_d != null) {
            mat.set(orientation_d);
        } else {
            return super.getRotationMatrix();
        }
        return mat;
    }

	/**
	 * This method gets the accuracy to which we compute the complete elliptic
	 * integral for this ring of current in computing its magnetic fields and
	 * flux function.  Default value is 0.0002
	 * 
	 * @return double representing the accuracy of the CEI calculation
	 */
	public double getCEIaccuracy() {
		return CEIaccuracy;
	}

	/**
	 * @see <code>getCEIaccuracy</code>
	 * @param accuracy  The accuracy of the CEI calculation
	 */
	public void setCEIaccuracy(double accuracy) {
		CEIaccuracy = accuracy;
	}
}
